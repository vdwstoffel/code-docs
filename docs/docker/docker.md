---
sidebar_label: "Docker"
sidebar_position: 400
---

# Docker

## Images

### Build an image

```bash
docker build -t my-image:my-tag .

docker build -f docker/Dockerfile -t my-image:my-tag .
```

### List all images

```bash
docker images
```

### Delete an image

```bash
docker rmi <image_name>

# Delete all unused images
docker image prune -a
```

### Push/Pull images to/from dockerhub

```bash
docker push <image_name>
docker pull <image_name>
```

## Containers

```md
-p: port
-d: detach (run in background)
--name: name the container
--rm: remove container once stopped
```

### List container

```bash
docker ps -a
```

### Run Container

```bash
docker run <image_name>

docker run -d -p <host_port>:<container_port> --name docker_example <image_name>
```

### Restart a container

```bash
docker restart <container_id>
```

### Stop a container

```bash
docker stop <container_id>
```

### Remove a container

```bash
docker rm <container_id>
```

```bash
docker run --rm <container_id> # remove container once stopped
```

### Container Logs

```bash
docker logs <container_id>
```

### Open a shell in a running container

```bash
docker exec -it <container_id> sh
```

## Volumes

### List all volumes

```bash
docker volume ls
```

### Remove a volume

```bash
docker volume rm <volume_name>
```

```bash
docker volume prune
```

### Named Volumes

Named volumes in Docker are a way to persist data generated by and used by Docker containers.
In this command, `volume_name` is the name of the volume and `/app/data` is the path in the container where the volume is mounted. If volume_name does not exist, Docker will create it.

```bash
docker run -v volume_name:/app/data my-docker-image
```

### Anonymous Volumes

They are used for data that persists while the container is running, but doesn't need to be kept after the container is removed.
In this command, `/app/data` is the path in the container where the anonymous volume is mounted. When the container is removed, the anonymous volume is also removed.

```bash
docker run -v /app/data my-image my-docker-image
```

### Bind Mounts

A bind mount in Docker is a method of attaching a specific directory or file from your host machine's filesystem directly into a Docker container. This allows the container to access and modify the files and directories on the host system as if they were part of the container's own filesystem. In this command, `/host/path` is the path on the host machine and `/container/path` is the path in the container where the host's directory is

```bash
docker run -v /path/on/host:/path/in/container my-docker-image
```

## Networks

Docker networks provide isolated and organized communication channels between containers, enhancing security and enabling efficient data exchange within Docker environments.

### Create a network

```bash
# First create a network
docker network create my-network_name
```

### List all networks

```bash
docker network ls
```

### Remove a network

```bash
docker network rm my-network_name
```

```bash
docker network prune
```

### Connect container to network

```bash
docker run --network my-network_name my-image:my-tag
```

## Dockerfile

### Basic Dockerfile

```dockerfile
FROM baseImage

WORKDIR /the/workdir/path

COPY from_source to_dest

RUN command                 # Runs when image is build, ex npm install, apt install, pip install

COPY from_source to_dest

EXPOSE port

VOLUME ["path/to/file"]     # add if you need anonymous volumes

CMD [ "executable" ]        # runs when container start
```

```bash
docker build -f /path/to/your/Dockerfile -t your-image-name .
```

### Variables in docker file

```dockerfile
FROM node:14-slim

# Create and change to the app directory.
WORKDIR /usr/src/app

# Set environment variables
// highlight-next-line
ENV PORT=8080

# Copy application dependency manifests to the container image.
# A wildcard is used to ensure copying both package.json AND package-lock.json (if available).
COPY package*.json ./
RUN npm instal

# Copy local code to the container image.
COPY . .

# Expose the port the app runs on
// highlight-next-line
EXPOSE $PORT

# Run the web service on container startup.
CMD [ "npm", "start" ]
```

### Env variables via cli

```bash
docker run -d -e MONGO_INITDB_ROOT_USERNAME=stoffel -e MONGO_INITDB_ROOT_PASSWORD=secret mongo:latest
```

### .env files via cli

```bash
docker run --env-file ./.env
```

### Arguments

```docker
ARG DEFAULT_PORT=80
ENV PORT $DEFAULT_PORT
```

```bash
# to change the port during build
docker build -t my-images:my-tag --build-arg DEFAULT_PORT=8080
```

### .dockerignore

Files/Folder to ignore

```docker
node_module/
Dockerfile
.git
.venv
```

## Docker-Compose

```txt
├── backend
│   ├── ...files
├── frontend
│   ├── ...files
├── docker-compose.yaml
```

```yaml title+"docker-compose.yaml"
version: "version" # docker-compose specification
services:
  # name your services
  service-name:
    image: imageName:tag # name of image (own name or use existing images ex mongo, node)
    build: path # when building your own Dockerfile
    container_name: name # give custom name to service
    ports:
      - "<host_port>:<container_port>"
    volumes:
      # named volumes
      - volume_name:/path/
      # relative path for bind mounts
      - ./backend:/app
      # anon volumes
      - /app/node_modules
    environment:
      - name=value # env variables
    env_file:
      - ./path/to/filename
    depends_on:
      - serviceName # other services (containers) it depends on

    # using interactive mode
    stdin_open: true
    tty: true

  # second-service:
  #   ...

volumes:
  # Top level volumes where you add your named volumes
  volume_name:
```

### build options

For Dockerfiles in nested folders, the build can be specified

```yaml
build:
  context: . #  specifies the build context as the root folder of your project.
  dockerfile: docker/Dockerfile # points to the Dockerfile in the "docker" folder.
```

Note that the copy should end with a `/` to specify a folder in the docker/Dockerfile

```docker
COPY package*.json ./
```

### Starting Containers

Starting from the same folder as the docker-compose.yaml.
Volumes and networks will automatically be created

```bash
docker-compose up           # supply services name if you do not want to run all
docker-compose up -d        # run in detached mode
docker-compose up --build   # rebuild the images
```

### Stopping Containers

Deletes all containers + network it created

```bash
docker-compose down

# to remove volumes (do not persist data)
docker-compose down -v
```

## Utility Containers

A utility container is a Docker container that is specifically designed to perform a single task or provide a specialized service to other containers.

```docker title="Dockerfile"
FROM node:18-alpine

WORKDIR /app

ENTRYPOINT [ "npm" ]    # initial arg to be run, other command will be appened
```

```yaml title="docker-compose.yaml"
version: "3.18"
services:
  # app services here
  # ...

  npm-test: # service name to be run in cli
    build: /path/to/dockerfile
    stdin_open: true # if applicable
    tty: true # if applicable
    volumes:
      - ./:/app
```

Then in the terminal run the chosen service

```bash
# docker-compose run --rm service_name arguments
docker-compose run --rm npm-test init    # runs npm init
docker-compose run --rm npm-test install # runs npm install
```

If you have other app containers in the docker-compose.yaml and don`t want to run the utility containers. Add depends_on to the service

```yaml
services:
  frontend:
    image: "node"
    depends_on:
      - backend
      - database
```

Then in the command line run

```bash
docker-compose up -d frontend
```

This will launch all the dependent services

### Run command in running container

```bash
docker-compose exec <container_name> npm install <package_name>
```
